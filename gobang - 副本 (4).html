<html>

<head>
    <title>gobang</title>
    <link href="canvas.css?v=105" rel="stylesheet" type="text/css">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js"></script>
    <script src="mcts.js"></script>
    <script>
        "use strict";   //使用严格模式

        $(function () {
            var board_sz = 10;
            var n_cnt = 5;
            var board_cvs = getCanvas("chessBoard");
            var chess_board = new board_canvas(board_sz, board_cvs.width);
            var chess_state = new board_state(board_sz, n_cnt);
            var tmp;

            //添加窗口尺寸改变响应监听
            $(window).resize(function () {
                var sz = (($(window).get(0).innerWidth > $(window).get(0).innerHeight) ?
                    $(window).get(0).innerHeight : $(window).get(0).innerWidth) * 0.85
                $("#chessBoard").attr("width", sz);
                $("#chessBoard").attr("height", sz);
                $("#fakeCvs").attr("width", 0);
                $("#fakeCvs").attr("height", 0);

                chess_board.boardResize(sz);
                drawChessBoard(chess_board, board_cvs);
                drawAllChesses(chess_board, chess_state, board_cvs);
            });
            $(window).trigger('resize');            //页面加载后先设置一下canvas大小
            printState(chess_state);

            //定义有输入时的处理：
            board_cvs.onmousedown = function (evt) {
                //alert("enable_input: " + chess_board.enable_input);
                if (chess_state.game_end == false && chess_board.enable_input == true) {
                    var pos = getClickPosXY(evt, board_cvs);
                    var chess_pos = chess_board.transColRow(pos.x, pos.y);
                    chessInBoardProc(chess_board, chess_state, board_cvs, chess_pos.row, chess_pos.col);
                    enableBoard(chess_board, chess_state, board_cvs, false);
                    setTimeout(UCT, 500, chess_state, chess_board, board_cvs, 100000);
                }
            }

            var evt = document.createEvent('Event');
            evt.initEvent('customEventRstGame', true, true);
            board_cvs.addEventListener('customEventRstGame', function () {  //按下"restart"的处理
                chess_state = new board_state(board_sz, n_cnt);
                drawChessBoard(chess_board, board_cvs);
                drawAllChesses(chess_board, chess_state, board_cvs);
                printState(chess_state);
            }, false);
        });

        function _UCTcbk(move, s, b, cvs) {
            //alert(move);
            var pos = s.move2pos(move);
            enableBoard(b, s, cvs, true);
            chessInBoardProc(b, s, cvs, pos.row, pos.col);
        }

        function enableBoard(chess_board, chess_state, board_cvs, enable_board) {
            if (enable_board == true) {
                drawChessBoard(chess_board, board_cvs);
                drawAllChesses(chess_board, chess_state, board_cvs);
                chess_board.enable_input = true;

                //alert("enable");
            } else {
                let context = getCanvasCtx(board_cvs);
                //画底盘
                context.fillStyle = "rgb(160, 160, 160)";
                context.globalAlpha = 0.2;
                context.fillRect(0, 0, chess_board.cvs_sz, chess_board.cvs_sz);
                context.globalAlpha = 1;
                chess_board.enable_input = false;

                //alert("disable");
            }
        }
        function getCanvas(eleId) {
            let cvs = document.getElementById(eleId);  //获取画布DOM  还不可以操作
            return cvs;
        }

        function getCanvasCtx(cvs) {
            let cxt = cvs.getContext('2d');   //设置绘图环境
            return cxt;
        }

        class board_canvas {
            constructor(board_sz, cvs_sz) {
                this.sz = board_sz;
                this.cvs_sz = cvs_sz;
                this.unit_space = 0;
                this.border = 0;
                this.chess_radius = 0;
                this.enable_input = true;
                this.boardResize(this.cvs_sz);
            }

            boardResize(cvs_sz) {
                this.cvs_sz = cvs_sz;
                this.border = Math.round(((this.cvs_sz) / (this.sz - 1)) * 0.35);
                this.unit_space = (this.cvs_sz - 2 * this.border) / (this.sz - 1);
                this.chess_radius = Math.round(this.unit_space / 3.5);
            }

            transColRow(x, y) {
                return {
                    col: Math.round((x - this.border) / this.unit_space),
                    row: Math.round((y - this.border) / this.unit_space)
                }
            }
        }

        class board_state {
            constructor(board_sz, n_cnt) {
                this.sz = board_sz;
                this.n = n_cnt;
                this.full_cnt = this.sz * this.sz;
                this.state = new Int8Array(this.full_cnt);
                this.last_move = -1;
                this.pid = 1; // 1为黑棋，2为白棋，初始化为黑棋
                this.game_end = false;
            }

            doMove(move) {
                if (this.state[move] != 0) {
                    return false;
                } else {
                    this.state[move] = this.pid;
                    this.pid = 3 - this.state[move];
                    this.last_move = move;
                    return true;
                }
            }

            doPosMove(row, col) {
                let move = this.pos2move(row, col);
                return this.doMove(move);
            }

            pos2move(row, col) {
                return row * this.sz + col;
            }

            move2pos(move) {
                return {
                    row: Math.floor(move / this.sz),
                    col: (move % this.sz)
                }
            }

            getMoves() {
                var moves = new Array();
                for (var i = 0, len = this.state.length; i < len; i++) {
                    if (this.state[i] != 0) {
                        moves.push(i);
                    }
                }
                return moves;
            }

            getNoneMoves() {
                var moves = new Array();
                for (var i = 0, len = this.state.length; i < len; i++) {
                    if (this.state[i] == 0) {
                        moves.push(i);
                    }
                }
                return moves;
            }

            getWinner() {
                var moves = this.getMoves();
                var s_cnt = 0;
                for (var i = 0, len = moves.length; i < len; i++) {
                    var move = moves[i];
                    var pos = this.move2pos(move);
                    //横
                    s_cnt = 1;
                    if (pos.row <= this.sz - this.n) {
                        for (var s = 1; s < this.n; s++)
                            if (this.state[move] == this.state[move + s]) s_cnt++;
                        if (s_cnt == this.n) return this.state[move];
                    }
                    //竖
                    s_cnt = 1;
                    if (pos.col <= this.sz - this.n) {
                        for (var s = 1; s < this.n; s++)
                            if (this.state[move] == this.state[move + s * this.sz]) s_cnt++;
                        if (s_cnt == this.n) return this.state[move];
                    }
                    //斜右下
                    s_cnt = 1;
                    if ((pos.row <= this.sz - this.n) && (pos.col <= this.sz - this.n)) {
                        for (var s = 1; s < this.n; s++)
                            if (this.state[move] == this.state[move + s * this.sz + s]) s_cnt++;
                        if (s_cnt == this.n) return this.state[move];
                    }
                    //斜左下
                    s_cnt = 1;
                    if ((pos.row <= this.sz - this.n) && (pos.col >= this.sz - this.n - 1)) {
                        for (var s = 1; s < this.n; s++)
                            if (this.state[move] == this.state[move + s * this.sz - s]) s_cnt++;
                        if (s_cnt == this.n) return this.state[move];
                    }
                }
                return 0;   //无胜方
            }
        }

        function getClickPosXY(evt, board_cvs) {
            evt = window.event || evt;
            //获取canvas相对于浏览器圆点的坐标
            var rect = board_cvs.getBoundingClientRect();
            return {
                //获取圆心的位置
                //获取鼠标在canvas上的位置
                x: (evt.pageX - rect.left) * (board_cvs.width / rect.width),
                y: (evt.pageY - rect.top) * (board_cvs.height / rect.height)
            }
        }

        function drawChessBoard(chessBoard, cvs) {
            let context = getCanvasCtx(cvs);

            //画底盘
            context.fillStyle = "rgb(252, 230, 199)";
            context.fillRect(0, 0, chessBoard.cvs_sz, chessBoard.cvs_sz);
            //先画外框
            context.lineWidth = 2;
            context.strokeStyle = "black";
            context.strokeRect(chessBoard.border, chessBoard.border,
                cvs.width - 2 * chessBoard.border,
                cvs.height - 2 * chessBoard.border);

            //再画内框
            context.lineWidth = 1;
            context.strokeStyle = "#6A6868";
            for (var i = 1; i < chessBoard.sz - 1; i++) {
                context.strokeRect(chessBoard.border + i * chessBoard.unit_space, chessBoard.border,
                    0, cvs.height - 2 * chessBoard.border);
                context.strokeRect(chessBoard.border, chessBoard.border + i * chessBoard.unit_space,
                    cvs.height - 2 * chessBoard.border, 0);
            }
        }

        function drawWinBoard(chessBoard, cvs, pid) {
            let context = getCanvasCtx(cvs);

            //画底盘
            context.fillStyle = "rgb(255, 0, 0)";
            context.globalAlpha = 0.1;
            context.fillRect(0, 0, chessBoard.cvs_sz, chessBoard.cvs_sz);
            context.globalAlpha = 1;
            //写字
            context.font = 'bold 60px Arial';
            context.fillStyle = 'blue';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText((pid == 1 ? "BLACK" : "WHITE") + ' Wining!!!', chessBoard.cvs_sz / 2, chessBoard.cvs_sz / 2);
        }

        function drawAChess(chessBoard, cvs, row, col, pid) {
            let player_color = (pid == 1) ? "black" : "white";

            let ctx = getCanvasCtx(cvs);
            ctx.beginPath();
            ctx.fillStyle = player_color;
            ctx.arc(chessBoard.border + col * chessBoard.unit_space,
                chessBoard.border + row * chessBoard.unit_space,
                chessBoard.chess_radius, 0, 360, false);
            ctx.fill();
            ctx.closePath();
            //alert(player_color + " drawed.");
        }

        function printState(chess_state) {
            var last_pid = 3 - chess_state.pid;
            var last_player_str = (last_pid == 1 ? "black" : "white");
            var cur_player_str = (chess_state.pid == 1 ? "black" : "white");
            var last_pos = chess_state.move2pos(chess_state.last_move);

            if (chess_state.last_move == -1) { //一盘新棋
                setElementText(cur_player_str + "_move", "");
                setElementText(last_player_str + "_move", "");
            } else {
                setElementText(last_player_str + "_move", last_pos.row + "," + last_pos.col);
            }
            setElementText(last_player_str + "_state", "waiting");
            setElementText(cur_player_str + "_state", "thinking");
        }

        function drawAllChesses(chessBoard, chessState, cvs) {
            for (var i = 0, len = chessState.state.length; i < len; i++) {
                if (chessState.state[i] != 0) {
                    var pos = chessState.move2pos(i);
                    drawAChess(chessBoard, cvs, pos.row, pos.col, chessState.state[i]);
                }
            }
        }

        function chessInBoardProc(chess_board, chess_state, board_cvs, row, col) {
            if (chess_state.doPosMove(row, col) == true) {
                drawAChess(chess_board, board_cvs, row, col, 3 - chess_state.pid);
                printState(chess_state);


            }

            var winner = chess_state.getWinner()
            if (winner != 0) {
                setElementText((winner == 1 ? "black" : "white") + "_state", "WIN!!!");
                setElementText(((3 - winner) == 1 ? "black" : "white") + "_state", "LOSE");
                chess_state.game_end = true;
                drawWinBoard(chess_board, board_cvs, winner);
            }
            return true;
        }

        function setElementText(eleId, eleText) {
            $("#" + eleId).text(eleText).show();
        }

        function onRstBtn() {
            var evt = document.createEvent('Event');
            evt.initEvent('customEventRstGame', true, true);
            var t_dom = document.getElementById("chessBoard");
            t_dom.dispatchEvent(evt)
        };
    </script>
</head>

<body>
    <h4>gobang powered by tensorflow.js</h4>
    <table class="gridtable">
        <tr>
            <th>Player</th>
            <th>Last Move</th>
            <th>Cur State</th>
            <th>OP</th>
        </tr>
        <tr>
            <td>BLACK</td>
            <td>
                <div id="black_move"></div>
            </td>
            <td>
                <div id="black_state"></div>
            </td>
            <td rowspan="2">
                <button class="button rosy" id="reset_btn" onclick="onRstBtn()"> restart </button>
            </td>

        </tr>
        <tr>
            <td>WHITE</td>
            <td>
                <div id="white_move"></div>
            </td>
            <td>
                <div id="white_state"></div>
            </td>
        </tr>

    </table>


    <canvas id="chessBoard">
        Your browser does not support Canvas. Please try the latest chrome.
    </canvas>
    <canvas id="fakeCvs"> </canvas>

</body>

</html>